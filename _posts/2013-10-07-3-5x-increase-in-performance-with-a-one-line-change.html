---
layout: post
status: publish
published: true
title: 3.5x Increase In Performance with a One-Line Change
author:
  display_name: Geoff Lane
  login: admin
  email: geoff@zorched.net
  url: http://www.zorched.net
author_login: admin
author_email: geoff@zorched.net
author_url: http://www.zorched.net
wordpress_id: 574
wordpress_url: http://www.zorched.net/?p=574
date: '2013-10-07 11:18:57 -0400'
date_gmt: '2013-10-07 17:18:57 -0400'
categories:
- Code
- Ruby
tags:
- ruby-on-rails
- performance
comments: []
---
<p>Gather around my friends, I'd like to tell you about a cure for what ails you, be it sniffles, scurvy, stomach ailments, eye sight, nervousness, gout, pneumonia, cancer, heart ailments, tiredness or plum just sick of life... Yes, sir, a bottle of my elixir will fix whatever ails you!</p></p>
<p>You might see the title above and think I'm trying to sell you some snake oil. The truth is, I probably am. As with most performance claims, your mileage may vary and the devil will always be in the details.</p></p>
<h2>Let's Start with a bit of Background</h2></p>
<p>I recently began working on a client's Ruby on Rails application that needed to provision data into another system at runtime. The provisioning was done through synchronous HTTP REST calls performed during the most performance critical request flow in the application. The flow that made up 95% of the overall traffic that this application handled. The provisioning consisted of between 8 and 15 HTTP requests to an external application.</p></p>
<p><em>record scratching</em></p></p>
<p>Yes, you read that correctly. For one HTTP request to this application, in the flow that made up 95% of the traffic that this application was supposed to handle, the app made up to 15 HTTP requests to a second system. This is not an ideal design from a performance standpoint of course. The ultimate goal would be to eliminate or substantially reduce the number of calls through a coarse grain interface. But that requires changes in two applications, coordinated across multiple teams, which will take a while. We needed to find something to do in the short term to help with the performance issues to give us the breathing room to make more extensive changes.</p></p>
<h2>The Good News</h2></p>
<p>Luckily the HTTP Requests were already being made using the <a href="https://github.com/lostisland/faraday">Faraday</a> library. Faraday is an HTTP client library which provides a consistent interface over different HTTP implementations. By default it uses the standard Ruby Net:HTTP library. Faraday is configured like this:</p></p>
<p><code lang="ruby"><br />
conn = Faraday.new(:url => 'http://example.com') do |faraday|<br />
  faraday.request :url_encoded # form-encode POST params<br />
  faraday.response :logger # log requests to STDOUT<br />
  faraday.adapter Faraday.default_adapter # make requests with Net::HTTP<br />
end<br />
</code></p></p>
<p>Net:HTTP in Faraday will create a new HTTP connection to the server for each request that is made. If you're only making one request or you're making requests to different hosts, this is perfectly fine. In our case, this was an HTTPS connection and all were being made to the same host. So for each of those 15 requests Net:HTTP was opening a new socket, negotiating some TCP, and negotiating an SSL connection. So how does Faraday help in this case?</p></p>
<p>One of the adapters that Faraday supports is <a href="http://docs.seattlerb.org/net-http-persistent/">net-http-persistent</a> which is a ruby library that supports persistent connections and HTTP Keep-Alive across multiple requests. HTTP Keep-Alive allows for an HTTP connection to be reused for multiple requests and avoids the TCP negotiation and SSL connection overhead. To use the net-http-persistent implementation all you have to do is to change your Faraday configuration to look like:</p></p>
<p><code lang="ruby"><br />
conn = Faraday.new(:url => 'http://example.com') do |faraday|<br />
  faraday.request :url_encoded # form-encode POST params<br />
  faraday.response :logger # log requests to STDOUT<br />
  faraday.adapter :net_http_persistent<br />
end<br />
</code></p></p>
<p>This simple change swaps out the HTTP implementation that is used to make the requests. In our case it reduced the average time to process a complete request (including the ~15 requests made using Faraday) under load from <em>8 seconds down to 2.3 seconds</em>.</p></p>
<p><em>the crowd goes wild</em></p></p>
<p>OK, so technically you need to add a new Gem reference to your Gemfile to use net-http-persistent. So it's not <em>REALLY</em> a One-Line Fix. I also hope you never have an interface so chatty that your application needs to make 15 calls to the same remote server to process one request. But if you do! Let me tell you my friend! Just a little drop of net-http-persistent is all you need to cure what ails you.</p></p>
<h3>P.S.</h3></p>
<p>Faraday has some other benefits including supporting a Middleware concept for processing requests and responses that allows for code to be shared easily across different HTTP requests. So you can have common support for handling JSON or for error handling or logging for example. This is a nice architecture that allows you to easily process request data. So even if you don't need it for its ability to switch out HTTP implementations, it's still a nice library to use.</p></p>
