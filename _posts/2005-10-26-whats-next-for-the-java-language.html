---
layout: post
status: publish
published: true
title: What's Next for the Java Language?
author:
  display_name: Geoff Lane
  login: admin
  email: geoff@zorched.net
  url: http://www.zorched.net
author_login: admin
author_email: geoff@zorched.net
author_url: http://www.zorched.net
excerpt: With Java 5 out for a while now I was thinking about what might be next for
  the Java language.
wordpress_id: 10
wordpress_url: http://www.zorched.net/?p=10
date: '2005-10-26 22:08:26 -0400'
date_gmt: '2005-10-27 03:08:26 -0400'
categories:
- Code
- Java
tags: []
comments:
- id: 4
  author: Chris
  author_email: chris.erin@gmail.com
  author_url: ''
  date: '2005-10-29 11:40:56 -0400'
  date_gmt: '2005-10-29 16:40:56 -0400'
  content: "I love most of the features in 1.5, Autoboxing being by far my favorite.
    \ If everything is an object, then why not have EVERYthing be an object?  Varargs
    are cool, and allow great flexibility without destroying type safety.  Enums are
    nice to have, but in .NET I always end up using the 'java enum' pattern anyways.
    \ I always want to say so much more about a particular status or label, most of
    the time I would like to have a user viewable version of that enum.  Why can't
    they implement enums based on strings?  Annotations seem nice to intellectually
    but I don't ever find myself saying, \"This is the perfect place for Annotations!\".
    \  I don't use them.  And then Generics..............\r\n\r\nI CAN'T STAND GENERICS\r\n\r\nThey
    make no sense to me.  Maybe I haven't had so much experience with them because
    .NET doesn't have a similiar type of thing, but Generics to me go one step too
    far in the battle for type safety.  To me, if you don't know what is going to
    be in a certain arraylist then you don't understand what the system is doing.
    \ Generics add COMPLEXITY to development in that you have to think through an
    extra set of technical implementation details when you really want to be thinking
    about the problem and how to solve it.  The complexity is unneeded and detrimental
    to a languages ease-of-use."
- id: 5
  author: Chris
  author_email: chris.erin@gmail.com
  author_url: ''
  date: '2005-10-29 12:19:25 -0400'
  date_gmt: '2005-10-29 17:19:25 -0400'
  content: "The language features that you list for 1.6 all seem to fall into a category
    of languages that I have seen described as 'Freedom Languages'.  C# and Java are
    business languages in this categorization. Ruby, Python, Smalltalk, etc are freedom
    languages.  If you have two sons, one trustworthy, one decidely not, then you
    may give them each a different level of freedom because of the likely consequences.
    \ One can't be trusted with the car, one can.  One can't be trusted babysitting
    the sister, one can.  In the business world, you can't tell which programmer can
    be trusted and which one can't, because typically your experience with that individual
    can be limited.  The consequences of giving an untrustworthy developer can be
    disastorous.  Bad programmers do so many funky things anyways, can you imagine
    what they would do with Full Closures, Coroutines, etc?  \r\n\r\nFreedom is needed
    by good programmers, and freedom helps the programmer to flourish, to dream up
    solutions that are ever more elegant and useful.  Freedom languages are needed
    by good programmers as an outlet for their personal or open source projects so
    that they can implement ideas more quickly and with more butter.  There is so
    much risk though in the business(millions$$$$) world that the advantages of freedom
    languages and features are outweighed.\r\n\r\nPROPERTIES\r\n\r\nI think properties
    as an implementation detail may be redundant.  They do though have a tendancy
    to communicate to developers the make-up of a state of an object.  The 'Get' word
    can mean different things and has the possibility to confuse what is a method
    accessing state and what is a method performing some action. The real world command
    'Get me some milk'  can have many different steps behind it, you could be getting
    in your car and going to the store, or you could be opening the refridgerator,
    pulling out the milk and checking for it's expiration.  The possibly exists to
    put many different steps behind a property, for sure, but this is typically done
    when wanting to present the action as state, rather than action (ahhhh abstraction).
    \ Subtle difference?  Large difference?  What does the tech blogging world or
    Geoff think?"
- id: 6
  author: Geoff Lane
  author_email: geoff@zorched.net
  author_url: http://www.zorched.net
  date: '2005-10-29 12:39:11 -0400'
  date_gmt: '2005-10-29 17:39:11 -0400'
  content: "Enums in Java are improved over Enums in .NET. Enums in Java are a full
    class, so they can have methods and other data. Basically, they've built-in the
    Enum Pattern but added the flexibility that you can use them as Integral types
    for things like switch statements and the like.\r\n\r\nGenerics are wonderful!
    They increase the readability and intentionality of the code. They allow other
    people that are using your code to more easily know how to use it, and better
    than comments they are compile time checked. So, if you don't know what a collection
    takes, the generics force you to know.\r\n(By the way, C# 2.0 has Generics and
    it was just released to MSDN on Oct. 28th)\r\n\r\nWith Generics:\r\n<code>\r\nlist.get(i).getValue();\r\n</code>\r\n\r\nvs.
    Without Generics:\r\n\r\n<code>\r\n((MyObject) list.get(i)).getValue();\r\n</code>\r\n\r\nThe
    other thing is that Generics are not only useful for Collections classes, but
    can be used by other, more general classes. It allows you to provide general functionality
    and an implementer to declare their own type safety mechanisms.\r\n\r\n<code>\r\npublic
    \ <T extends Person &amp; Comparable>void doSomething(T person) {\r\n    //
    ...\r\n}\r\n</code>\r\n\r\nAgain, with something like this you don't have
    to test if the object passed in is both a Person and Comparable, you know that
    the compiler has confirmed this for you.\r\n\r\nIn the end, I think generics have
    the possibility of reducing errors and increasing readability of the intentions
    of the programmer, both of which are Good Things &mark;."
- id: 65
  author: Rossi
  author_email: rgreinke@emsystem.com
  author_url: ''
  date: '2006-02-27 16:48:29 -0500'
  date_gmt: '2006-02-27 22:48:29 -0500'
  content: "About finalize():  Not only do you not know when a GC will be performed,
    it is possible that a GC may NEVER be called.  This is one of the reasons that
    finalize() is relegated to the same chapter as the GOTO statement.  :)  \r\n\r\nOne
    can guarantee (to some extent) object cleanup by using a try/finally block,
    but that puts the responsibility on the consumer of a particular class, not the
    class' designer.  Obviously the dispose() method comes from the C++ destructor
    concept, which never really got ported to Java (other than the half-a$$ attempt
    called finalize()."
- id: 2279
  author: Zorched / One Line Fix &raquo; Welcome Java 6
  author_email: ''
  author_url: http://www.zorched.net/2006/12/13/welcome-java-6/
  date: '2006-12-13 21:32:40 -0500'
  date_gmt: '2006-12-14 03:32:40 -0500'
  content: "[...] Similarly tagged posts Hibernate Query TranslatorsjMock For Mocking
    Unit TestsHibernate HQL And PerformanceRelentless Build AutomationContinuous Integration
    RevisitedTapestry and Hibernate Take 2Why Do Tapestry and Hibernate Fight So Much?Remoting:
    Tight or Loose Coupling?What's Next for the Java Language?More On MSBuildMSBuild
    with NUnitFake Materialized ViewsPragmatic Project AutomationAjax with JSON using
    PHP and DOJOOracle Materialized ViewsRJS Templates for RailsSubversion Maintenance
    ScriptsJavascript Code FormattingJavascript 1.7 in Firefox 2.0Getting the Revision
    Number of your Subversion Working CopyMKE Ruby GroupMilwaukee Wisconsin Ruby BrigadeJavaScript
    ToolkitsMore WebDAV Tips, Tricks and BugsRuby Features You'll Wish You Had In
    Other LanguagesRuby Quiz Metaprogramming ChallengeRuby SOAP4R For Web ServicesCustom
    WebDAV Server Using .NETExcellent Cheat SheetsRuby REXML - Another Take on XML
    ParsingASP.NET Web Application Without .ASPX ExtensionWhat are Decentralized Revision
    Control Systems.NET Nullable Types and DBNull Expose Design FlawsFastSOA DiscussionVS.NET
    Developers Should Use ReSharperServer Side Include (SSI) Templating [...]"
---
<p>With Java 5 having been out for a while now, I started to think about what might be next for the Java language. I'm not thinking about what might change with JEE (nee J2EE), or the extensions or libraries or anything like that. I'm thinking about the core language itself. There were not a lot of changes between Java 1.1 and Java 1.4. The <code>assert</code> keyword was added and there were a number of additions to the core libraries such as NIO, but again, I wanted to think about the language itself and not the libraries so much.</p>
<h3>What's New in Java 5</h3><br />
Java 5 saw a lot of changes many of which, at least on appearances, seem to be a response to the .NET platform and the C# language. A little bit of healthy competition spurred on some advancements in the language. To start, I wanted to think a little about these recent changes because there are some really great language enhancements in Java 1.5.</p>
<h4>Type safe Enums</h4><br />
<em>Type safe Enums</em> have added a full-class citizen of the Enum Pattern to the Java language. This is in many ways a better implementation than the C# version in that they are full classes that can have methods and data that belong to them as well. As is often the case with Enum types there are a number of associated helper methods that pertain to the Enum and the class itself is the most logical place for it to live.</p>
<h4>Generics</h4><br />
<em>Generics</em> offer compile time checking that allows you to create type safe but generic classes. The most often used example of this is type safe collections classes.</p>
<h4>Varargs</h4><br />
<em>Varargs</em> allows a method creator to accept a variable number of arguments to a method. This means the the user of the method does not have to manually create an array of arguments (it lets the compiler do the work for you). This is a handy extension.</p>
<h4>Annotations</h4><br />
<em>Annotations</em> allow for an easy way to add metadata to classes, methods, etc. This is great for tools and frameworks such as unit testing and extensions like aspect-oriented programming.</p>
<h4>'Enhanced' for loop (read foreach loops)</h4><br />
The new for loop provides an easy way to iterate over a collection without having to manually test exit conditions or do type casting.</p>
<h4>Autoboxing</h4><br />
The automatic conversion of Objects to primitive scalar types and vice-versa.</p>
<p><small><br />
(Most of the features are backwards compatible with previous JVM versions once they are compiled, but they are also areas where there is potential for non-backwards compatible optimizations in the future.)<br />
</small></p>
<h3>What's Next for Java 6?</h3><br />
I won't claim all of these are likely or for that matter even good ideas. This is my attempt to brainstorm some possibilities for discussion purposes.</p>
<h4>Full Closures</h4><br />
Java has support for a form of closure using anonymous classes, but <em>Full Closure</em> support is not there. Full Closures are similar to pointers to functions in some ways. It allows libraries to allow for the customization of behavior by passing a closure as an argument to a method call. A common example of this is a filter passed to a method that iterates over a collection to return a sub-collection. Full Closures also allow the sharing of variables both in a code block and out of the code block (so changes in one area effect the other). With anonymous classes in Java, the variables passed into the method have to be final to that method. Full Closures have been re-popularized by languages like <a href="http://www.braithwaite-lee.com/tips/closures.html">Ruby</a> and Python and of course older languages like Lisp.</p>
<h5>Functions as First-Class Citizens</h5><br />
Full Closures often are implemented as functions. This might require the idea of having functions as first-class objects. This is not as crazy as it sounds, this is done in other programming languages such as <a href="http://builder.com.com/5100-6371-1044599.html">JavaScript</a>. Of course with functions as first-class objects it also opens up the possibilities of dynamically adding methods to an object or class, like JavaScript or delegation features like many other languages including C#.</p>
<h4>Coroutines</h4><br />
Subroutines are a special case of a <em>Coroutine</em> that have only a single entry and exit point. Coroutines on the other hand have multiple potential entry points. A Coroutine will "remember" where it last left the routine and will begin just after that point when the routine is again invoked. This is a very helpful way to build things like state machines without having to do a bunch of if-then conditionals in a method. See the <a href="http://docs.python.org/ref/yield.html">yield statement in Python</a> as an example.</p>
<h4>Allowing the Separation of Object Allocation and Initialization</h4><br />
The <code>new</code> keyword in languages like Java and C# perform two functions:</p>
<ol>
<li>Allocate memory on the heap for the object to live.</li>
<li>Initialize the object</li><br />
</ol></p>
<p>A constructor only allows you to control the initialization of the object, not the allocation aspects of that object. The allocation is a low-level routine that is done for you. Some languages like Objective C separate these constructs <code>[[Object alloc] init]</code>. Allowing some control over the allocation would allow for built-in support for things like <a href="http://en.wikipedia.org/wiki/Abstract_factory_pattern">Factory patterns</a> and even for things like distributed objects by instantiating an instance on a remote system and returning a Proxy to that object.<br />
<small>(I think this one probably falls into the ABSOLUTE least likely to happen, but it's cool to think about.)</small></p>
<h4>Deterministic Disposal</h4><br />
Java has the <code>finalize()</code> method which is called prior to garbage collection of an object. Garbage collection is not deterministic in that you can not know when a specific object will be <acronym title="Garbage Collected">GC</acronym>ed. The <code>finalize()</code> method is therefore only useful for special cases regarding memory cleanup.</p>
<p>Disposal (ala C# IDisposable interface) on the other hand can be used to cleanup any resource because the <code>dispose()</code> method is called when an object goes out of scope. This can be used to cleanup non-memory resources like IO or SQL connections, rollback uncommitted transaction, whatever you want.</p>
<h3>Some Things I Hope They Leave Out</h3></p>
<h4>C#-esque Properties</h4><br />
<em>Properties</em> are a shortcut for creating accessors and mutators (getters and setters) in C#. Properties are really compiled into methods behind the scenes. Why does this matter? Because implementation sometimes matters and can have side effects. Direct access to an object variable is not the same as accessing an object through a method. Going through a method the object is accessed through a copy of a pointer (pass by reference vs pass by value issues). While this is not a common issue you would run into, if you ever did figuring out these interactions could be much more difficult.</p>
<p><code><br />
x.Arg = new Object():<br />
Object y = x.Arg;<br />
x.Arg = new Object();<br />
</code></p>
<p>If <code>x.Arg</code> is a direct variable access, then <code>Arg</code> and <code>y</code> will be the same value in the end because they point to the same memory location. If they are methods, then they will be two different objects. Weird huh?</p>
<h3>What Else?</h3><br />
There's a constant battle between extending the language with useful functionality and keeping the implementation clean and true to a coherent design philosophy.</p>
<p>What am I missing? What can or should be added to Java that would improve the language, but not destroy it's nature?</p>
