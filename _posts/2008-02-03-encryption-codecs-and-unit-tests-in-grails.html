---
layout: post
status: publish
published: true
title: Encryption, Codecs and Unit Tests in Grails
author:
  display_name: Geoff Lane
  login: admin
  email: geoff@zorched.net
  url: http://www.zorched.net
author_login: admin
author_email: geoff@zorched.net
author_url: http://www.zorched.net
wordpress_id: 97
wordpress_url: http://www.zorched.net/2008/02/03/encryption-codecs-and-unit-tests-in-grails/
date: '2008-02-03 10:25:35 -0500'
date_gmt: '2008-02-03 16:25:35 -0500'
categories:
- Groovy
tags:
- grails
- encryption
- codecs
comments:
- id: 14411
  author: Andres Galeano
  author_email: agaleano@versatile.com
  author_url: http://blogs.versatile.com/
  date: '2009-01-06 10:16:30 -0500'
  date_gmt: '2009-01-06 16:16:30 -0500'
  content: "Hi there,\r\n\r\nThank you very much for a great post.  This was very
    useful in my grails application.\r\nI did change one thing.  I wanted to allow
    for longer passwords then 16 characters.  So I split the password in fourths,
    generated hash-codes, then wrote them to the array.\r\n\r\n<code lang=\"groovy\">\r\nprivate
    static setupCipher(mode, password) {\r\n  // setup key\r\n  byte[] keyBytes
    = new byte[16];\r\n  final int len = password.length();\r\n  // four 'int's
    in sixteen bytes\r\n  for(i in 0..<4) {\r\n    // grab the hashcode of
    one forth of the string: 0..1/4, 1/4..2/4, 2/4..3/4, 3/4..4/4\r\n
    \   int hc = password.substring( (int)((len * i)/4), (int)((len * (i+1))/4)
    ).hashCode();\r\n    // split an int into four bytes:\r\n    keyBytes[i
    * 4 + 0] =(byte)(  hc >> 24 );\r\n    keyBytes[i * 4 + 1] =(byte)( (hc << 8) >>
    24 );\r\n    keyBytes[i * 4 + 2] =(byte)( (hc << 16) >> 24 );\r\n    keyBytes[i
    * 4 + 3] =(byte)( (hc << 24) >> 24 );\r\n  }\r\n\r\n  SecretKeySpec keySpec =
    new SecretKeySpec(keyBytes, \"AES\");\r\n  // ...\r\n</code>\r\n\r\nAnd
    Thanks again,\r\n- Andy G\r\n"
- id: 14412
  author: Geoff Lane
  author_email: geoff@zorched.net
  author_url: http://www.zorched.net
  date: '2009-01-06 10:35:18 -0500'
  date_gmt: '2009-01-06 16:35:18 -0500'
  content: Andy, Thanks for sharing that with us.
- id: 16044
  author: Ulrich Enslin
  author_email: ulrichenslin@gmail.com
  author_url: http://www.i3zone.com
  date: '2010-02-19 13:50:04 -0500'
  date_gmt: '2010-02-19 19:50:04 -0500'
  content: This is a great post.  Exactly what I needed.
---
<p>Certain data stored as plain text in a database is just asking for trouble these days. We hear too often about misplaced and stolen computers that contain databases full of Social Security numbers and other information that can lead to identity theft. We can help avoid these situations by encrypting those fields in a database so that if someone happens to get the data that they will have a difficult time getting the sensitive data.</p>
<h3>Codecs</h3><br />
Grails provides a very good mechanism for this encryption in its <a href="http://grails.org/doc/1.0.x/ref/Plug-ins/codecs.html">Codec support</a>. Codecs allow you to create encoders and decoders that become very easy to use in your application. Grails comes with a few useful ones built in to do things like Base64, URL, HTML, and Javascript Encoding.</p>
<p>Anywhere you have a string you can call the encodeAs<em>CodecName</em> or decode<em>CodecName</em> to perform the encoding or decoding:<br />
<code  lang="groovy"><br />
assert "apples &amp; oranges " == "apples & oranges".encodeAsHTML()<br />
assert "apples & oranges " == "apples &amp; oranges".decodeHTML()<br />
</code></p>
<p>This is a nice, generally useful utility that can be used for any kind of string conversion really. There's nothing from stopping you from creating your <em>encodeAsInteger</em> or <em>decodeShortDate</em> if that's something you need a lot of in your application.</p>
<p>The basic format of a Codec is simple. You can create your new Codec in the <em>grails-app/utils</em> directory and it will be found automatically by Grails based on the naming convention.<br />
<code lang="groovy"><br />
class MyCodec {<br />
    static encode = { str -><br />
        // Implement encoding here<br />
    }<br />
    static decode = { str -><br />
        // Implement decoding here<br />
    }<br />
}<br />
</code></p>
<h3>Encryption Codec</h3><br />
In my case I wanted to create something to do encryption. Luckily this is not so hard with the javax.crypto classes. The crypto API is not the most straight forward to use in the world, but with a little bit of reading you can figure out how to encrypt and decrypt data without a lot of hassle. Basically what you see is a fairly simple encryption routine wrapped in the Grails Codec standard.</p>
<p>As you saw from previous example, the Codec standard is really simple, so all of the complexity here is really just the encryption code.</p>
<p><code lang="groovy"><br />
import javax.crypto.spec.SecretKeySpec<br />
import javax.crypto.Cipher<br />
import javax.crypto.spec.IvParameterSpec<br />
import sun.misc.BASE64Encoder<br />
import sun.misc.BASE64Decoder<br />
import org.codehaus.groovy.grails.commons.ConfigurationHolder<br />
/**<br />
* Used for encrypting things to store in the database<br />
*/<br />
class SecureCodec {</p>
<p>    static BASE64Decoder decoder = new BASE64Decoder()<br />
    static BASE64Encoder encoder = new BASE64Encoder()</p>
<p>    static encode = { str -><br />
        Cipher cipher = setupCipher(Cipher.ENCRYPT_MODE, getPassword())<br />
        return encoder.encode(cipher.doFinal(str.getBytes()));<br />
    }</p>
<p>    static decode = { str -><br />
        Cipher cipher = setupCipher(Cipher.DECRYPT_MODE, getPassword())<br />
        return new String(cipher.doFinal(decoder.decodeBuffer(str)));<br />
    }</p>
<p>    static getPassword() {<br />
        return ConfigurationHolder.config.encryption.password<br />
    }</p>
<p>    private static setupCipher(mode, password) {<br />
        Cipher cipher = Cipher.getInstance("AES/CBC/PKCS5Padding");</p>
<p>        // setup key<br />
        byte[] keyBytes = new byte[16];<br />
        byte[] b = password.getBytes("UTF-8");<br />
        int len = b.length;<br />
        if (len > keyBytes.length)<br />
              len = keyBytes.length;<br />
        System.arraycopy(b, 0, keyBytes, 0, len);<br />
        SecretKeySpec keySpec = new SecretKeySpec(keyBytes, "AES");</p>
<p>        IvParameterSpec ivSpec = new IvParameterSpec(keyBytes);<br />
        cipher.init(mode, keySpec, ivSpec);<br />
        return cipher<br />
    }<br />
}<br />
</code></p>
<p>Another handy thing to notice is the <em>ConfigurationHolder.config</em>. This is the way to access application properties defined in Config.groovy. In a Domain class or a Controller you can get those values using <em>grailsApplication.config</em> but the grailsApplication variable is not available in Codecs or other classes. I use the Config.groovy to define an application specific secret to use for the encryption.</p>
<h3>Testing Your Codec</h3><br />
Now to confirm that the code works we can write a Unit Tests. Encryption and Codecs are the perfect example of checking an Inverse Relationships to confirm the functionality of the Codec. Basically just encode it and decode it and compare the original value to the decoded value. If they match, it worked! </p>
<h4>As a Unit Test</h4><br />
Outside the context of your running Grails application your Codec is just another Groovy class. Testing it in a Unit Test is easy though. You can just instantiate an instance of it and call the closures like they are methods.<br />
<code lang="groovy"><br />
class SecureCodecTests extends GroovyTestCase {</p>
<p>    void test_roundtrip_decodes_to_the_same_thing() {<br />
        SecureCodec codec = new SecureCodec()<br />
        def original = "secret"<br />
        def encoded = codec.encode(original)<br />
        def decoded = codec.decode(encoded)</p>
<p>        assert original != encoded<br />
        assert encoded != decoded<br />
        assert original == decoded<br />
    }<br />
}<br />
</code></p>
<h4>As an Integration Test</h4><br />
If you want to be able to test it as it will be used in your Grails application though, you will need to run it as an integration test. The integration tests are loaded, instrumented and run just like they would be by the real Grails application. To do that, you just have to create the test under the <em>tests/integration</em> directory of your Grails application.<br />
<code lang="groovy"><br />
class SecureCodecTests extends GroovyTestCase {</p>
<p>    void test_roundtrip_decodes_to_the_same_thing() {<br />
        def original = "secret"<br />
        def encoded = original.encodeAsSecure()<br />
        def decoded = encoded.decodeSecure()</p>
<p>        assert original != encoded<br />
        assert encoded != decoded<br />
        assert original == decoded<br />
    }<br />
}<br />
</code></p>
