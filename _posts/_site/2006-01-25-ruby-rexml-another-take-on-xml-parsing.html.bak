<p>If you are a programmer and have not been living under a rock, you've heard of <a href="http://www.ruby-lang.org">Ruby</a>. There's been a lot of hype built up around the language recently. Its even more hyped progeny <a href="http://www.rubyonrails.com">Ruby on Rails</a> highlight the strengths of this dynamic language. A seemingly large number of thought leaders in the software development space have also taken to the language as a primary tool in their toolkit.</p>
<p>Curious about the hype, and looking for something interesting to learn, I've recently started playing around with the Ruby programming language and Rails. I hope to write some more in detail about it at some point, but thought I would share some thoughts on one of the available Ruby XML parsers.</p>
<p><a href="http://www.germane-software.com/software/rexml/">REXML</a> is a pure Ruby implementation of an XML parser. It was inspired by an Open Source Java XML parser called Electric XML. Basically the whole point of REXML is to make an XML parser that feels like a Ruby library. It is a reaction to the SAX and the DOM parsers that exist. SAX and DOM parsers are generally available in all kinds of languages, but they are really tightly coupled to the demands of XML. </p>
<p>As a bit of background: SAX is an event-based model that parses a document in a single pass triggering event callbacks when specific elements are reached. The programmer is then responsible for deciphering the context and calling the appropriate functions. DOM on the other hand is a heirarchical, in-memory representation of an XML document. It allows for ad-hoc traversal of the XML structure. DOM also allows for the use of things like XPath for querying elements (attributes too) of an XML structure.</p>
<p>REXML on the other hand aims to feel like Ruby.</p>
<p>Creating a document:
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">doc</span> <span class="o">=</span> <span class="no">REXML</span><span class="o">::</span><span class="no">Document</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">atom_feed</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">doc</span><span class="p">.</span><span class="nf">root</span><span class="p">()</span></code></pre></figure></p>
<p>Getting a single text node:
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">linkNode</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="nf">elements</span><span class="p">[</span><span class="s1">'link'</span><span class="p">]</span>
<span class="n">linkValue</span> <span class="o">=</span> <span class="n">linkNode</span><span class="p">.</span><span class="nf">text</span> <span class="k">if</span> <span class="n">linkNode</span></code></pre></figure></p>
<p>REXML also uses the standard Enumerable features found by other collections classes so that it feels very natural to use. In Ruby it is common to use "blocks" to handle each of the items in a method. Rather than having to itterate over a collection of items, you let the collection do the itterating for you.</p>
<p>For each of the elements called "author" call the add_author method:
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">root</span><span class="p">.</span><span class="nf">elements</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="s1">'author'</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">a</span><span class="o">|</span> <span class="n">add_author</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="p">}</span></code></pre></figure></p>
<p>You can also use XPath:
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="no">XPath</span><span class="p">.</span><span class="nf">each</span><span class="p">(</span><span class="n">doc</span><span class="p">,</span> <span class="s2">"//entry"</span><span class="p">)</span> <span class="p">{</span> <span class="o">|</span><span class="n">e</span><span class="o">|</span> <span class="n">add_entry</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="p">}</span></code></pre></figure></p>
<p>Of course you can create and/or modify documents as well in a Ruby-esque way.
<figure class="highlight"><pre><code class="language-ruby" data-lang="ruby"><span class="n">entry</span> <span class="o">=</span> <span class="no">Element</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"entry"</span><span class="p">)</span>
<span class="nb">id</span> <span class="o">=</span> <span class="no">Element</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"id"</span><span class="p">)</span>
<span class="nb">id</span><span class="p">.</span><span class="nf">add_element</span><span class="p">(</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"_some_unique_id"</span><span class="p">))</span>
<span class="n">entry</span><span class="p">.</span><span class="nf">add_element</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>
<span class="p">[</span><span class="s1">'Geoff'</span><span class="p">,</span> <span class="s1">'Bob'</span><span class="p">,</span> <span class="s1">'Sam'</span><span class="p">].</span><span class="nf">each</span> <span class="k">do</span> <span class="o">|</span><span class="n">author</span><span class="o">|</span>
    <span class="n">a</span> <span class="o">=</span> <span class="no">Element</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"author"</span><span class="p">)</span>
    <span class="nb">name</span> <span class="o">=</span> <span class="no">Element</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="s2">"name"</span><span class="p">)</span>
    <span class="nb">name</span><span class="p">.</span><span class="nf">add_element</span><span class="p">(</span><span class="no">Text</span><span class="p">.</span><span class="nf">new</span><span class="p">(</span><span class="n">author</span><span class="p">))</span>
    <span class="n">entry</span><span class="p">.</span><span class="nf">elements</span> <span class="o">&lt;&lt;</span> <span class="n">a</span>
<span class="k">end</span></code></pre></figure></p>
<p>It's nice to see a slightly different take on XML manipulation.</p>
